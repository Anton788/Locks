№1\
Ни один из локов не сработает, LockOne и LockTwo никак не ограничивают от взаимной блокировки с двумя потоками, плюс JVM кэширует значение переменных, поэтому лок петерсона тоже не работает.

"Поможет ли использование объявление victim как volatile в случае LockTwo?" - нет, т.к. данный лок завершается успешно только при одновременной работе двух потоков, а volatile никак не способствует этому. Но volatile помогает в локе Петерсона.
В LockZero выполнены 2 из трех условий Mutex.
1) Взаимное исключение не выполняется, потому что нету никаких интсрументов синхронизации и каждый поток, не зная ничего о другом проходит в крит. секцию.
2) Отсутствие дедлока выполняется, потому что оба потока никак не пересекаются (нет общих переменных или общих полей в массиве), потому нет ситуации, когда возникнет дедлок
3) Отсутсвие голодания также выполняется, потому что нет ситуации бесконечного ожидание какого-либо потока, каждый поток при выполнении в любой момент времени может продвинуться вперед.

№2

В классе ConcurrentCounter я взял класс ConcurrentLinkedQueue, который реализует безопасную неограниченную очередь. Чтобы узнать значение счетчика - нужно посчитать длину очереди. Каждый поток при инкременте добавляет один элемент в конец очереди.

В классе MagicCounter реализован FilterLock(из книжки), вместо обычных массивов взяты аналоги thread-safe.